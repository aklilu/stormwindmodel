# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Adds forward speed component to modeled surface wind (C++ version)
#'
#' Adds the storm's forward speed component back into the estimated
#' surface wind speed at a grid point location.
#'
#' @param wind_sfc_sym A numeric vector with maximum 10-meter 1-minute
#'    sustained wind with motion asymmetry removed (m / s).
#' @param tcspd_u A numeric vector with the tropical cyclone speed, u-component
#'    (m / s).
#' @param tcspd_v A numeric vector with the tropical cyclone speed, v-component
#'    (m / s).
#' @param swd A numeric vector with surface wind direction (degree).
#' @inheritParams add_inflow
#' @inheritParams will3_right
#'
#' @return A numeric vector giving asymmeric surface windspeed (m / s)
#'
#' @details
#'
#' This function uses equation 12 from Phadke et al. (2003).
#'
#' @references
#'
#' Phadke AC, Martino CD, Cheung KF, and Houston SH. 2003. Modeling of
#'    tropical cyclone winds and waves for emergency management. Ocean
#'    Engineering 30(4):553-578.
degrees_to_radians_Cpp <- function(degrees) {
    .Call('stormwindmodel_degrees_to_radians_Cpp', PACKAGE = 'stormwindmodel', degrees)
}

add_forward_speed_Cpp <- function(wind_sfc_sym, tcspd_u, tcspd_v, swd, cdist, Rmax) {
    .Call('stormwindmodel_add_forward_speed_Cpp', PACKAGE = 'stormwindmodel', wind_sfc_sym, tcspd_u, tcspd_v, swd, cdist, Rmax)
}

#' Add inflow angle (C++ version)
#'
#' This function adds an inflow angle to the angle of the wind direction.
#' It calculates an inflow angle as a function of the distance from the
#' storm center to a location (Phadke et al. 2003), and then adds 20 degrees to
#' this inflow angle to account for the location being over land rather than
#' over water.
#'
#' @param gwd A numeric vector giving direction of gradient wind at a location,
#'    in degrees. Due east is 0 degrees, due north 90 degrees, etc.
#' @param cdist A numeric vector giving radius (in kilometers) from the storm
#'    center to a location.
#' @inheritParams will3_right
#'
#' @return Numeric vector with the gradient wind direction (in degrees),
#'    adjusted with an inflow angle appropriate for being over land and for the
#'    location's distance from the storm's center.
#'
#' @details
#'
#' This function uses equations 11a-c from Phadke et al. (2003).
#'
#' @references
#'
#' Phadke AC, Martino CD, Cheung KF, and Houston SH. 2003. Modeling of
#'    tropical cyclone winds and waves for emergency management. Ocean
#'    Engineering 30(4):553-578.
#'
#' @examples
#' add_inflow(gwd = 160, cdist = 100, Rmax = 20)
#'
#' @export
add_inflow_Cpp <- function(gwd, cdist, Rmax) {
    .Call('stormwindmodel_add_inflow_Cpp', PACKAGE = 'stormwindmodel', gwd, cdist, Rmax)
}

#' Calculate bearing from one location to another (C++ version)
#'
#' Calculates the bearing of a second location, as seen from
#' the first location, based on latitude and longitude coordinates for both
#' locations.
#'
#' @inheritParams latlon_to_km
#'
#' @return A numeric vector giving the direction of the second location from the first location,
#'    in degrees. A direction of 0 degrees indicates the second location is
#'    due east of the first, 90 degrees indicates the second location is due
#'    north of the first, etc.
#'
#' @details This function uses the following equations to calculate the bearing
#'    from one latitude-longitude pair to another:
#'
#'    \deqn{S = cos(\phi_2) * sin(L_1 - L_2)}{
#'    S = cos(\phi2) * sin(L1 - L1)}
#'
#'    \deqn{C = cos(\phi_1) * sin(\phi_2) - sin(\phi_1) * cos(\phi_2) * cos(L_1 - L_2)}{
#'    C = cos(\phi1) * sin(\phi2) - sin(\phi1) * cos(\phi2) * cos(L1 - L2)}
#'
#'    \deqn{\theta = atan2(S, C) * \frac{180}{\pi} + 90}
#'
#'    where:
#'    \itemize{
#'      \item{\eqn{\phi_1}{\phi1}: Latitude of first location, in radians}
#'      \item{\eqn{L_1}{L1}: Longitude of first location, in radians}
#'      \item{\eqn{\phi_2}{\phi2}: Latitude of second location, in radians}
#'      \item{\eqn{L_2}{L2}: Longitude of second location, in radians}
#'      \item{\eqn{S, C}: Intermediary results}
#'      \item{\eqn{\theta}: Direction of the storm movement, in degrees}
#'    }
#'
#'    In cases where this equation results in values below 0 degrees or above
#'    360 degrees, the function applies modular arithmetic to bring the value
#'    back within the 0--360 degree range.
#'
#' @export
degrees_to_radians_Cpp1 <- function(degrees) {
    .Call('stormwindmodel_degrees_to_radians_Cpp1', PACKAGE = 'stormwindmodel', degrees)
}

radians_to_degrees_Cpp1 <- function(radians) {
    .Call('stormwindmodel_radians_to_degrees_Cpp1', PACKAGE = 'stormwindmodel', radians)
}

calc_bearing_Cpp <- function(tclat_1, tclon_1, tclat_2, tclon_2) {
    .Call('stormwindmodel_calc_bearing_Cpp', PACKAGE = 'stormwindmodel', tclat_1, tclon_1, tclat_2, tclon_2)
}

#' Calculate surface wind speed from gradient (C++ version)
#' Calculates the surface wind speed based on an estimated gradient
#' wind speed at a point and the radius from the storm center to
#' the grid point.
#'
#' @param wind_gl_aa A numerical value with estimated gradient-level wind speed
#'    (m / s) at a grid point.
#' @param cdist A numerical value with radius from storm center to the grid
#'    point, in kilometers.
#'
#' @return A numeric vector with the estimated symmetric surface wind speed at
#'    the grid point, in meters / second.
#'
#' @details The reduction factor is based on Figure 3 of Knaff et al., 2003.
#' Over water, it is estimated to be 0.9 up to a radius of 100 km,
#' 0.75 for a radius of 700 km or more, and decrease linearly between
#' a radius of 100 km and 700 km. Points over land should use a reduction
#' factor that is 20\% lower. Because all of the counties are over
#' land, the function makes this adjustment for all grid points.
#'
#' @references
#'
#' Knaff JA, DeMaria M, Molenar DA, Sampson CR, and Seybold MG. 2011. An
#' automated, objective, multiple-satellite-platform tropical cyclone surface
#' wind speed analysis. Journal of Applied Meteorology and Climatology
#' 50(10):2149-2166
#'
#' @export
gradient_to_surface_Cpp <- function(wind_gl_aa, cdist) {
    .Call('stormwindmodel_gradient_to_surface_Cpp', PACKAGE = 'stormwindmodel', wind_gl_aa, cdist)
}

#' Calculate distance between two locations (C++ version)
#'
#' This function takes latitudes and longitudes for two locations and
#' calculates the distance (in meters) between the locations using the
#' Haversine method.
#'
#' @param tclat_1 A numeric vector giving latitude of the first location
#'    (degrees)
#' @param tclon_1 A numeric vector giving longitude of the first location
#'    (degrees). This value should be expressed as a positive value for Western
#'    hemisphere longitudes.
#' @param tclat_2 A numeric vector giving latitude of the second location
#'    (degrees)
#' @param tclon_2 A numeric vector giving longitude of the second location
#'    (degrees). This value should be expressed as a positive value for Western
#'    hemisphere longitudes.
#' @param Rearth Radius of the earth (km). Default is 6378.14 km.
#'
#' @return A vector with the distance between the two locations, in kilometers.
#'
#' @details This function uses the Haversine method with great circle distance
#'    to calculate this distance. It is applying the following equations to
#'    determine distance (in kilometers) between two latitude-longitude pairs:
#'    \deqn{hav(\gamma) = hav(\phi_1 - \phi_2) + cos(\phi_1)*cos(\phi_2)*hav(L_1 - L_2)}{
#'    hav(\gamma) = hav(\phi1 - \phi2) + cos(\phi1)*cos(\phi2)*hav(L1 - L2)}
#'    where:
#'    \itemize{
#'      \item{\eqn{\phi_1}{\phi1}: Latitude of first location, in radians}
#'      \item{\eqn{\phi_2}{\phi2}: Latitude of second location, in radians}
#'      \item{\eqn{L_1}{L1}: Longitude of first location, in radians}
#'      \item{\eqn{L_2}{L2}: Longitude of second location, in radians}
#'      \item{\eqn{hav(\gamma)}: The haversine function,
#'         \eqn{hav(\gamma) = sin^2 \left(\frac{\gamma}{2}\right)}{
#'         hav(\gamma) = sin^2 (\gamma / 2)}}
#'      \item{\eqn{R_earth}{Rearth}: Radius of the earth, here assumed to be 6378.14 kilometers}
#'      \item{\eqn{D}}: Distance between the two locations, in kilometers
#'    }
#'
#' @export
degrees_to_radians_Cpp2 <- function(degrees) {
    .Call('stormwindmodel_degrees_to_radians_Cpp2', PACKAGE = 'stormwindmodel', degrees)
}

latlon_to_km_Cpp <- function(tclat_1, tclon_1, tclat_2, tclon_2, Rearth = 6378.14) {
    .Call('stormwindmodel_latlon_to_km_Cpp', PACKAGE = 'stormwindmodel', tclat_1, tclon_1, tclat_2, tclon_2, Rearth)
}

#' Model wind speed at a grid point for a storm track observation (C++ version)
#'
#' Models the gradient wind speed at a certain radius from
#' a storm's center. To do this, it uses different equations and subfunctions
#' depending on how large the radius is (see details). This function requires,
#' as inputs, Willoughby wind model parameters calculated using the
#' \code{\link{add_wind_radii}} function.
#'
#' @param cdist Distance (in km) from center of tropical cyclone to grid point.
#' @param R1 A numeric vector of one of the parameters of the Willoughby model.
#' @param R2 A numeric vector of one of the parameters of the Willoughby model.
#' @param X2 A numeric vector of one of the parameters of the Willoughby model.
#' @inheritParams will1a
#' @inheritParams will3_right
#'
#' @return Returns a numeric vector with gradient wind speed at a radius of
#'    \eqn{r} from the storm's center, in meters per second.
#'
#' @details If \eqn{r \le R_1}{r \le R1}, this function is calculating the equation:
#'
#'    \deqn{V(r) = V_i = V_{max} \left( \frac{r}{R_{max}} \right)^n}{
#'    V(r) = Vi = vmax_gl (r / Rmax)^n}
#'
#'    where:
#'    \itemize{
#'      \item{\eqn{V(r)}: Maximum sustained gradient wind speed at a radius of
#'        \eqn{r} from the storm's center}
#'      \item{\eqn{r}: Radius from the storm center, in kilometers}
#'      \item{\eqn{V_{max,G}}{vmax_gl}: Maximum sustained gradient wind speed of the
#'        storm, in meters per second}
#'      \item{\eqn{R_1}{R1}: A parameter for the Willoughby wind model (radius to
#'        start of transition region)}
#'      \item{\eqn{R_{max}}{Rmax}: Radius (in kilometers) to highest winds}
#'      \item{\eqn{n}: A parameter for the Willoughby wind model}
#'    }
#'
#'    If \eqn{R_2 < r}{R2 \le r}, this function is calculating
#'      the equation:
#'
#'      \deqn{V(r) = V_o = V_{max}\left[(1 - A) e^\frac{R_{max} - r}{X_1} + A e^\frac{R_{max} - r}{X_2}\right]}{
#'      V(r) = Vo = vmax_gl[(1 - A) e^((Rmax - r) / X1) + A e^((Rmax - r) / X_2)]}
#'
#'    where:
#'    \itemize{
#'      \item{\eqn{V(r)}: Maximum sustained gradient wind speed at a radius of
#'        \eqn{r} kilometers from the storm's center}
#'      \item{\eqn{r}: Radius from the storm center, in kilometers}
#'      \item{\eqn{V_{max,G}}{vmax_gl}: Maximum sustained gradient wind speed of the
#'        storm, in meters per second}
#'      \item{\eqn{R_{max}}{Rmax}: Radius (in kilometers) to highest winds}
#'      \item{\eqn{A}, \eqn{X_1}{X1}, \eqn{X_2}{X2}: Parameters for the
#'         Willoughby wind model}
#'    }
#'
#'    If \eqn{R_1 < r \le R_2}{R1 < r \le R2}, this function uses
#'      the equations:
#'
#'      \deqn{\xi = \frac{r - R_1}{R_2 - R_1}}{
#'      \xi = (r - R1) / (R2 - R1)}
#'
#'      and, if \eqn{0 \le \xi < \le 1} (otherwise, \eqn{w = 0}):
#'
#'      \deqn{w = 126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9}
#'
#'      and then:
#'
#'      \deqn{V(r) = V_i (1 - w) + V_o w, (R_1 \le r \le R_2)}{
#'      V(r) = Vi (1 - w) + Vo w}
#'
#'    where, for this series of equations:
#'    \itemize{
#'      \item{\eqn{V(r)}: Maximum sustained gradient wind speed at a radius of
#'        \eqn{r} kilometers from the storm's center}
#'      \item{\eqn{r}: Radius from the storm center, in kilometers}
#'      \item{\eqn{w}: Weighting variable}
#'      \item{\eqn{R_1}{R1}, \eqn{R_2}{R2}: Parameters for the Willoughby wind model}
#'    }
#'
#' @references
#'
#' Willoughby HE, Darling RWR, and Rahn ME. 2006. Parametric representation
#' of the primary hurricane vortex. Part II: A new family of sectionally
#' continuous profiles. Monthly Weather Review 134(4):1102-1120.
#'
#' @export
will1_Cpp <- function(cdist, Rmax, R1, R2, vmax_gl, n, A, X1, X2 = 25) {
    .Call('stormwindmodel_will1_Cpp', PACKAGE = 'stormwindmodel', cdist, Rmax, R1, R2, vmax_gl, n, A, X1, X2)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('stormwindmodel_RcppExport_registerCCallable', PACKAGE = 'stormwindmodel')
})
